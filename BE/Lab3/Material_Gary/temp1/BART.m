function [Meta,RMSE,yhat] = BART(trainx, trainy, alpha, beta, m, v, ...
    nu, q, pgrow, pprune, iter, burn)
    
    [ntrain,p] = size(trainx);
    if length(trainy) ~= ntrain
        disp('Size of X not compatible with length of Y. Check the train set!');
    end
%% More hyperparameters to calculate
    % sigmamu and mumu
    miny = min(trainy);
    maxy = max(trainy);
    mumu = 0;
    sigmamu = 0.5/(nu*sqrt(m));
    sigmamu2 = sigmamu^2;
    
    %lambda (relates to prior for error variance, see subsection 2.2.4 of Chipman et al)
    lm = fitlm(trainx, trainy);
    residuals = table2array(lm.Residuals);
    residuals = residuals(:,1);
    sigma2 = residuals'*residuals/(ntrain-p);
    lambdatemp = @(lambda) lambdafxn(nu,q,sigma2,lambda);
    lambda = fminsearch(lambdatemp,1);
    
%% Transform y into ytilta \in [-0.5, 0.5]
    ytilta = -0.5+(trainy - miny)/(maxy-miny);
    trainset = [ytilta, trainx];

%% Initialize the tree T and corresponding M
    for ind = 1:m       
        T(ind).Terminal=1;
        T(ind).Parent=0;
        T(ind).Splitnode=[];
        T(ind).Splitvar=[];
        T(ind).Splitrule=[];
        T(ind).t1 = trainset;
        T(ind).Index = ones(ntrain,1);
    end
    T = T';
    for ind = 1:m
        M(ind).mu = mean(ytilta)/m;
        M(ind).G = (M(ind).mu*(T(ind).Index==T(ind).Terminal)')';
    end
    M = M';

%% Iterations
rng('default')
    for i = 1:iter
        disp([ num2str(i-iter) ' more draws to go...']);
        for j = 1:m
            t = length(T(j).Terminal);
            if t == 1 % When there is only one node, trees can only be proposed to grow
               % When there is only one node, trees can only be proposed to grow
                Tterminal = T(j).Terminal; % terminal nodes index
                
                % Uniformly selecting which node to grow on 
                probnode = (1/t:1/t:1); % cdf of probability of selecting each terminal node
                node = find(probnode>rand,1);
                Ssplit = Tterminal(node); % splitting node index
                
                % How deep is the selected node: deta
                a = Ssplit;
                deta = 0;
                while a ~= 1
                    deta = deta+1;
                    a = floor(a/2);
                end
                
                % Uniformly selecting splitting variable: the kth
                % covariates to split on
                probx = (1/p:1/p:1);
                k = find(probx>rand,1);
                
                % Uniformly selecting splitting rule
                splitname = strcat('t',num2str(Ssplit)); % name the splitting node
                xgrow = T(j).(splitname)(:,k+1); 
                %ygrow = T(j).(splitname)(:,1);
                [~,ia,~]=unique(xgrow);
                neta = length(ia); % number of unique values left in the kth covariate
                probvalue = (1/neta:1/neta:1);
                e = find(probvalue > rand,1);
                splitvalue = xgrow(ia(e));
                
                % Calculate the M-H ratio
                % 1. Calculate w2_star:number of internal nodes which have
                % only two children terminal nodes, after growth
                %Tterminalbefore = Tterminal; % store the Tterminal in last iteration in case the proposal is rejected           
                newTterminal = [2*Ssplit, 2*Ssplit+1]; % new terminal nodes generated by the grow step
                Tterminal = Tterminal(Tterminal~=Ssplit); % delete the splitting node in the terminal node set
                Tterminal(end+1:end+length(newTterminal))=newTterminal; % add the new terminals
                Tterminal = sort(Tterminal);
                temp = Tterminal(rem(Tterminal,2)==0);
                w2_star = sum(ismember((temp)+1,Tterminal)); % the number of internal nodes which have only two children terminal nodes
                
                % 2. Calculate Rj
                sumG = sum(cat(3,M.G),3);
                Rj = ytilta - (sumG - M(j).G);
                
                % which Rjs are in this selected splitting node?
                Rl = Rj(T(j).Index == Ssplit);
                nl = length(Rl);
                
                % which Rjs are going to be in the left and right node?
                RL = Rl(xgrow<=splitvalue);
                nL = length(RL);
                RR = Rl(xgrow>splitvalue);
                nR = length(RR);
                
                % 3. M-H ratio
                logA = log(pprune/pgrow)+log(t*p*neta)-log(w2_star);
                logB = (1/2)*(log(sigma2*(sigma2+nl*sigmamu2))-log((sigma2+nL*sigmamu2)*(sigma2+nR*sigmamu2)))+...
                    sigmamu2/(2*sigma2)*((sum(RL))^2/(sigma2+nL*sigmamu2)+(sum(RR))^2/(sigma2+nR*sigmamu2)-(sum(Rl))^2/(sigma2+nl*sigmamu2));
                logC = log(alpha)+2*log(1-alpha/(2+deta)^beta)-log((1+deta)^beta-alpha)-log(p*neta);            
                logr = logA+logB+logC;
                
                % Accept or not?
                ug1 = rand;
                if log(ug1) <= logr % Accept and grow on the selected splitting node with the splitting rule, renew the tree structure
                   % T(j).Node = [T(j).Node, 2*Ssplit, 2*Ssplit+1]; % Store all the nodes in Tj
                    T(j).Terminal = Tterminal;
                    temp = Tterminal(rem(Tterminal,2)==0);
                    parent = temp(ismember(Tterminal(rem(Tterminal,2)==0)+1,Tterminal))/2;
                    T(j).Parent = parent; % Store the parent node with 2 children              
                    T(j).Splitnode = [T(j).Splitnode, Ssplit]; % Store the split terminal node
                    T(j).Splitvar = [T(j).Splitvar, k]; % Store the split variable
                    T(j).Splitrule =[T(j).Splitrule, splitvalue]; % Store the split rule
                    T(j).Index(T(j).Index == Ssplit)= 0; % The splitting node index should be removed from the index vector
                    
                % Store the splitted sample according to the splitting
                % rules on the terminal nodes
                    for ind = 1:length(newTterminal)
                        nam = newTterminal(ind);                       
                        myfield = strcat('t',num2str(nam));                      
                            if rem(nam,2) == 0
                                T(j).(myfield) = T(j).(splitname)(xgrow<=splitvalue,:);                            
                            elseif rem(nam,2) ~= 0
                                T(j).(myfield) = T(j).(splitname)(xgrow>splitvalue,:);
                            end
                        T(j).Index = nam * ismember(trainx,T(j).(myfield)(:,2:end),'row')+T(j).Index;% Which obs is in which terminal nodes at last?                                                                         
                    end                                  
                end
          
            elseif t>1
                u2 = rand;
                if u2 <= 1/3 %grow
                    % which node to grow on
                    Tterminal = T(j).Terminal;
                    probnode = (1/t:1/t:1);
                    Ssplit = Tterminal(find(probnode>rand,1));
                    % how deep is this node
                    a = Ssplit;
                    deta = 0;
                    while a ~= 1
                        deta = deta+1;
                        a = floor(a/2);
                    end
                    % which splitting variable: the kth covariate
                    varnum = 0;
                    varlist = [];
                    splitname = strcat('t',num2str(Ssplit));
                    splitx = T(j).(splitname)(:,2:end);
                    for pi = 1:p
                        [~,ia,~] = unique(splitx(:,pi));
                        nunique = length(ia);
                        if nunique >= 2
                            varnum = varnum+1;
                            varlist = [varlist, pi];
                        end
                    end
                    probx = (1/varnum:1/varnum:1);
                    k = varlist(find(probx>rand,1));
                    
                    % which splitting rule to use?
                    xgrow = T(j).(splitname)(:,k+1);
                    [~,ia,~] = unique(xgrow);
                    neta = length(ia);
                    probvalue = (1/neta:1/neta:1);
                    e = find(probvalue>rand,1);
                    splitvalue = xgrow(ia(e));
                    
                    % Calculate M-H ratio
                    %Tterminalbefore = Tterminal;
                    newTterminal = [2*Ssplit, 2*Ssplit+1];
                    Tterminal = Tterminal(Tterminal ~= Ssplit);
                    Tterminal(end+1:end+length(newTterminal)) = newTterminal;
                    Tterminal = sort(Tterminal);
                    temp = Tterminal(rem(Tterminal,2)==0);
                    w2_star = sum(ismember((temp+1),Tterminal));
                    
                    sumG = sum(cat(3,M.G),3);
                    Rj = ytilta - (sumG - M(j).G);
                    Rl = Rj(T(j).Index == Ssplit);
                    nl = length(Rl);
                    RL = Rl(xgrow<=splitvalue);
                    nL = length(RL);
                    RR = Rl(xgrow>splitvalue);
                    nR = length(RR);
                    
                    logA = log(pprune/pgrow)+log(t*p*neta)-log(w2_star);
                    logB = (1/2)*(log(sigma2*(sigma2+nl*sigmamu2))-log((sigma2+nL*sigmamu2)*(sigma2+nR*sigmamu2)))+...
                        sigmamu2/(2*sigma2)*((sum(RL))^2/(sigma2+nL*sigmamu2)+(sum(RR))^2/(sigma2+nR*sigmamu2)-(sum(Rl))^2/(sigma2+nl*sigmamu2));
                    logC = log(alpha)+2*log(1-alpha/(2+deta)^beta)-log((1+deta)^beta-alpha)-log(p*neta);            
                    logr = logA+logB+logC;
                    
                    % Accept or not?
                    ug2 = rand;
                    if log(ug2) <= logr % Accept and grow on the selected splitting node with the splitting rule, renew the tree structure
                %T(j).Node = [T(j).Node, 2*Ssplit, 2*Ssplit+1]; % Store all the nodes in Tj
                    T(j).Terminal = Tterminal;                
                    temp = Tterminal(rem(Tterminal,2)==0);
                    parent = temp(ismember(Tterminal(rem(Tterminal,2)==0)+1,Tterminal))/2;
                    T(j).Parent = parent; % Store the parent node with 2 children              
                    T(j).Splitnode = [T(j).Splitnode, Ssplit]; % Store the split terminal node
                    T(j).Splitvar = [T(j).Splitvar, k]; % Store the split variable
                    T(j).Splitrule =[T(j).Splitrule, splitvalue]; % Store the split rule
                    T(j).Index(T(j).Index == Ssplit)= 0; %
                    
                % Store the splitted sample according to the splitting
                % rules on the terminal nodes
                    for ind = 1:length(newTterminal)
                        nam = newTterminal(ind);                       
                        myfield = strcat('t',num2str(nam));                       
                            if rem(nam,2) == 0
                                T(j).(myfield) = T(j).(splitname)(xgrow<=splitvalue,:);                            
                            elseif rem(nam,2) ~= 0
                                T(j).(myfield) = T(j).(splitname)(xgrow>splitvalue,:);
                            end
                        T(j).Index = nam * ismember(trainx,T(j).(myfield)(:,2:end),'row')+T(j).Index;% Which obs is in which terminal nodes at last?                                                                         
                    end
                    end
                
                elseif u2 > 1/3 && u2 <= 2/3 %prune
                    % Uniformly selecting which terminal node to prune on (must
                    % be on the node with 2 parent of 2 children).
                    parent = T(j).Parent;
                    prunenode = [2*parent, 2*parent+1];
                    prunet = length(prunenode);
                    probnode = (1/prunet:1/prunet:1);
                    Sprune = prunenode(find(probnode>rand,1));
                    pruneparent = floor(Sprune/2);
                    
                    % How deep is the parent of the selected terminal node?
                    a = Sprune;
                    detastar = 0;
                    while a ~= 1
                        detastar = detastar + 1;
                        a = floor(a/2);
                    end
                    detastar = detastar - 1;
                    
                    % Calculate the M-H ratio
                    % 1. Calculate all the needed numbers
                    w2 = length(parent); % number of singly internal parent nodes which have two terminal children
                    parentname = strcat('t',num2str(pruneparent)); % parent's index 
                    splitvar = T(j).Splitvar(find(T(j).Splitnode == pruneparent, 1, 'last' )); % splitting variable on the parent
                    xgrow = T(j).(parentname)(:,splitvar+1);
                
                    [~,ia,~]=unique(xgrow);
                    netastar = length(ia);
                    splitvalue = T(j).Splitrule(find(T(j).Splitnode==pruneparent, 1, 'last' )); % splitting rule on the parent
                     % 2. Calculate Rj
                    sumG = sum(cat(3,M.G),3);
                    Rj = ytilta - (sumG - M(j).G);
                    % which Rjs are in this selected splitting node?
                    Rl = Rj(T(j).Index == pruneparent*2 | T(j).Index == pruneparent*2+1);
                    nl = length(Rl);
                
                    % which Rjs are going to be in the left and right node?
                    RL = Rl(xgrow<=splitvalue);
                    nL = length(RL);
                    RR = Rl(xgrow>splitvalue);
                    nR = length(RR);
                    
                    % 3. Calculate the M-H ratio
                    logAp = log(pgrow/pprune)+log(w2)-log((t-1)*p*netastar);
                    logBp = -((1/2)*(log(sigma2*(sigma2+nl*sigmamu2))-log((sigma2+nL*sigmamu2)*(sigma2+nR*sigmamu2)))+...
                         sigmamu2/(2*sigma2)*((sum(RL))^2/(sigma2+nL*sigmamu2)+(sum(RR))^2/(sigma2+nR*sigmamu2)-(sum(Rl))^2/(sigma2+nl*sigmamu2)));
                    logCp = -(log(alpha)+2*log(1-alpha/(2+detastar)^beta)-log((1+detastar)^beta-alpha)-log(p*netastar));            
                    logrp = logAp+logBp+logCp;
                    
                    % Accept or not?
                    up = rand;
                    if log(up) <= logrp % Accept and prune to the parent node, delete the 2 children node
                    nodetoprune = [2*pruneparent, 2*pruneparent+1];
                    %T(j).Node(find(T(j).Node == nodetoprune(1)|T(j).Node == nodetoprune(2))) = []; % remove node from stored nodes 
                    T(j).Terminal(find(T(j).Terminal == nodetoprune(1)|T(j).Terminal == nodetoprune(2)))=[]; % remove terminal nodes from stored terminal nodes
                    T(j).Terminal = sort([T(j).Terminal, pruneparent]);
                    
                    Tterminal=T(j).Terminal;   
                    temp = Tterminal(rem(Tterminal,2)==0);
                    parent = temp(ismember(Tterminal(rem(Tterminal,2)==0)+1,Tterminal))/2;
                    T(j).Parent = parent;  % remove the former parent node from the Parent vector
                    
                    if isempty(T(j).Parent)==1 % if there is no parent node with 2 children, index it with 0
                        T(j).Parent = 0;
                    end
                    
                    % how does T(j).Index change?
                    T(j).Index(find(T(j).Index == (pruneparent*2) | T(j).Index == (pruneparent*2+1)))=pruneparent; % Those formerly with the two pruned node index are now indexed with their parent's index
                    
                    % how does the T(j).t# change? all the pruned node
                    % disappear
                    prunednode = [pruneparent*2, pruneparent*2+1];
                    for ind = 1:length(prunednode)
                        nam = prunednode(ind);
                        myfield = strcat('t',num2str(nam));
                        T(j).(myfield) = [];
                    end                                     
                    end
                    
                elseif u2 > 2/3 && u2 <= 1 %change
                    % Pick a parent node with 2 children
                    parent = T(j).Parent;
                    changeprob = (1/length(parent):1/length(parent):1);
                    parentindex = parent(find(changeprob>rand,1)); % node index for this selected parent
        
                    % Find the original splitting variable and splitting rule
                    sv = T(j).Splitvar(find(T(j).Splitnode == parentindex, 1, 'last'));
                    sr = T(j).Splitrule(find(T(j).Splitnode == parentindex, 1, 'last'));
        
                    % Find the corresponding dataset
                    parentname = strcat('t',num2str(parentindex));
                    xchange = T(j).(parentname)(:,sv+1);
                    % Calculate the corresponding R
                    sumG = sum(cat(3,M.G),3);
                    Rj = ytilta - (sumG - M(j).G);
                    Rl = Rj(T(j).Index == (parentindex*2) | T(j).Index == (parentindex*2+1));
                    nl = length(Rl);
                    RL = Rl(xchange<=sr);
                    nL = length(RL);
                    RR = Rl(xchange>sr);
                    nR = length(RR);
                    % Pick a new splitting variable and a new splitting rule
                    % 1. how many covariates contain more than 2 unique values?
                    varnum = 0;
                    varlist = [];
                    splitname = strcat('t',num2str(parentindex));
                    splitx = T(j).(splitname)(:,2:end);
                    for pi = 1:p
                        [~,ia,~] = unique(splitx(:,pi));
                        nunique = length(ia);
                        if nunique >= 2
                            varnum = varnum+1;
                            varlist = [varlist,pi];
                        end
                    end
                    % 2. which covariate to choose?
                    probx = (1/varnum:1/varnum:1);
                    svstar = varlist(find(probx>rand,1));
                    xchangestar = T(j).(parentname)(:,svstar+1);
                    [~,ia,~] = unique(xchangestar);
                    neta = length(ia);             
                    probvalue = (1/neta:1/neta:1);
                    e=find(probvalue>rand,1);
                    srstar = xchangestar(ia(e));
                    
                    % Calculate the corresponding Rj
                    RLstar = Rl(xchangestar <= srstar);
                    nLstar = length(RLstar);
                    RRstar = Rl(xchangestar > srstar);
                    nRstar = length(RRstar);
                    % Calculate the M-H ratio = Likelihood ratio
                    logBc = 1/2*(log(sigma2/sigmamu2+nL)+log(sigma2/sigmamu2+nR)-log(sigma2/sigmamu2+nLstar)-log(sigma2/sigmamu2+nRstar))+...
                        (1/(2*sigma2))*((sum(RLstar))^2/(nLstar+sigma2/sigmamu2)+(sum(RRstar))^2/(nRstar+sigma2/sigmamu2)-(sum(RL))^2/(nL+sigma2/sigmamu2)-(sum(RR))^2/(nR+sigma2/sigmamu2));
                    
                    % Accept or not?
                   uc = rand;
                   if log(uc)<=logBc % Accept this change. Store the parentindex in the splitnode matrix and store the sv and sr in the corresponding matrix
                      T(j).Splitnode = [T(j).Splitnode, parentindex];
                      T(j).Splitvar = [T(j).Splitvar,svstar];
                      T(j).Splitrule = [T(j).Splitrule, srstar];
            
                   % drop the original sample in the old terminal nodes and store the new splitted sample
                      Terminal = [2*parentindex, 2*parentindex+1];
                      for ind = 1:length(Terminal)
                          nam = Terminal(ind);
                          myfield = strcat('t',num2str(nam));
                          T(j).(myfield) = [];
                          T(j).Index(T(j).Index == nam) = 0;
                      end
            
                      for indafter = 1:length(Terminal)
                          nam = Terminal(indafter);
                          myfield = strcat('t',num2str(nam));                          
                          if rem(nam,2) == 0
                              T(j).(myfield) = T(j).(parentname)(xchangestar<=srstar,:);
                          elseif rem(nam,2) ~= 0
                              T(j).(myfield) = T(j).(parentname)(xchangestar > srstar,:);
                          end
                          T(j).Index = nam * ismember(trainx,T(j).(myfield)(:,2:end),'row')+T(j).Index;
                      end
                   end % end of accept to change or not
                end  %end of u>pgrow
            end % end of t = 1
        
        % Sample terminal nodes muij from normal distribution, there are
        % length(Tterminal of j) many of muij
        M(j).mu = [];
        B = length(T(j).Terminal); % number of terminals now
        for b = 1:B % select mu for each terminal node
            % which node is it?
            index = T(j).Terminal(b);
            %nodename = strcat('t', num2str(index));
        
            % Calculate Rj
            sumG = sum(cat(3,M.G),3);
            Rj = ytilta - (sumG-M(j).G);
        
            % Decide which Rj are on which terminal node
            Rbj = Rj(T(j).Index == index); % Rj which are on the bth terminal node
            nb = length(Rbj); % how many of Rj are on the bth terminal node
        
            % Calculate the mean
            meanmu = (sigmamu2*sum(Rbj)+sigma2*mumu)/(nb*sigmamu2+sigma2); % mean of the posterior distribution of muij    
        
           % Calculate the variance
            variancemu = sigma2*sigmamu2/(nb*sigmamu2+sigma2); % variance of the posterior distribution of muij
            if variancemu < 0
                disp('Variance of muij is negative');
            end
        
            % Sample and store mu
            M(j).mu(b) = meanmu+sqrt(variancemu)*randn(1);
        end
        
            % Store g(x,T,M) for each observation
            M(j).G = zeros(ntrain,1);
        for bi = 1:B
            M(j).G = M(j).mu(bi)*(T(j).Index==T(j).Terminal(bi))+M(j).G;
        end                   
        end % end of tree iteration
        % Sample sigma2 from inverse gamma
        abar = (nu+ntrain)/2;
        temp = sum((ytilta - sum(cat(3,M.G),3)).^2);
        bbar = 1/2*(nu*lambda+temp);
        sigma2 = 1./gamrnd(abar,1/bbar);
    
        % Store the structure
        if i > burn
            Meta(i-burn).Tree = T;
            Meta(i-burn).Outcome = M;
            Meta(i-burn).Variance = sigma2;
        end    
    end % end of iterations
    ytiltahat = sum(cat(3,Meta(iter-burn).Outcome.G),3);
    %BART typically standardizes dep var to lie in [-0.5,0.5], following
    %line transforms back to orginal units
    yhat = (ytiltahat+0.5)*(maxy-miny)+miny;
    RMSE = sqrt(mean((trainy - yhat).^2));
end